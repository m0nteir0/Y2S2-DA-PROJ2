<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.5"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>2nd DA Project: Data Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">2nd DA Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.5 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="class_data-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">Data Class Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a0cce205a1314635a99dc86902abdfa31"><td class="memItemLeft" align="right" valign="top"><a id="a0cce205a1314635a99dc86902abdfa31" name="a0cce205a1314635a99dc86902abdfa31"></a>
<a class="el" href="class_graph.html">Graph</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>getG</b> ()</td></tr>
<tr class="separator:a0cce205a1314635a99dc86902abdfa31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d68124b7a2f41ccd294c1fdb266ab2e"><td class="memItemLeft" align="right" valign="top"><a id="a5d68124b7a2f41ccd294c1fdb266ab2e" name="a5d68124b7a2f41ccd294c1fdb266ab2e"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>readToyData</b> (string filename)</td></tr>
<tr class="separator:a5d68124b7a2f41ccd294c1fdb266ab2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeecfd8a42c8751063511aefa81324520"><td class="memItemLeft" align="right" valign="top"><a id="aeecfd8a42c8751063511aefa81324520" name="aeecfd8a42c8751063511aefa81324520"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>readFullyConnectedData</b> (string filename)</td></tr>
<tr class="separator:aeecfd8a42c8751063511aefa81324520"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3409b472c590f4027699d554be2d5a38"><td class="memItemLeft" align="right" valign="top"><a id="a3409b472c590f4027699d554be2d5a38" name="a3409b472c590f4027699d554be2d5a38"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>readRealData</b> (string folder)</td></tr>
<tr class="separator:a3409b472c590f4027699d554be2d5a38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad85894af01995458983b6fa9e3b25b69"><td class="memItemLeft" align="right" valign="top"><a id="ad85894af01995458983b6fa9e3b25b69" name="ad85894af01995458983b6fa9e3b25b69"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>readRealNodes</b> (string filename)</td></tr>
<tr class="separator:ad85894af01995458983b6fa9e3b25b69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaaa4a432defb3db40269f4fef8295a34"><td class="memItemLeft" align="right" valign="top"><a id="aaaa4a432defb3db40269f4fef8295a34" name="aaaa4a432defb3db40269f4fef8295a34"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>readRealEdges</b> (string filename)</td></tr>
<tr class="separator:aaaa4a432defb3db40269f4fef8295a34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1947b3d8101c095e648980d3d7a6fd61"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_data.html#a1947b3d8101c095e648980d3d7a6fd61">tspBTAux</a> (unsigned int n, int path[], int currentPath[], double curr, double &amp;best, unsigned int curr_n)</td></tr>
<tr class="memdesc:a1947b3d8101c095e648980d3d7a6fd61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliar function to solve the Travelling Salesperson Problem (TSP) using a Backtracking algorithm.  <a href="class_data.html#a1947b3d8101c095e648980d3d7a6fd61">More...</a><br /></td></tr>
<tr class="separator:a1947b3d8101c095e648980d3d7a6fd61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4962c86093432dd3093b71805add323a"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_data.html#a4962c86093432dd3093b71805add323a">tspBT</a> (unsigned int n, int path[])</td></tr>
<tr class="memdesc:a4962c86093432dd3093b71805add323a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solves the Travelling Salesperson Problem (TSP) using a Backtracking algorithm.  <a href="class_data.html#a4962c86093432dd3093b71805add323a">More...</a><br /></td></tr>
<tr class="separator:a4962c86093432dd3093b71805add323a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8887ef4ba084b4f8c60858e9d16ef0a8"><td class="memItemLeft" align="right" valign="top">vector&lt; <a class="el" href="class_vertex.html">Vertex</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_data.html#a8887ef4ba084b4f8c60858e9d16ef0a8">getPreorderWalk</a> ()</td></tr>
<tr class="memdesc:a8887ef4ba084b4f8c60858e9d16ef0a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the Preorder Walk of the <a class="el" href="class_graph.html">Graph</a>.  <a href="class_data.html#a8887ef4ba084b4f8c60858e9d16ef0a8">More...</a><br /></td></tr>
<tr class="separator:a8887ef4ba084b4f8c60858e9d16ef0a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab96c3f81fbb888c414a2f850d0121ee7"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_data.html#ab96c3f81fbb888c414a2f850d0121ee7">tspTriangle</a> (vector&lt; <a class="el" href="class_vertex.html">Vertex</a> * &gt; &amp;path)</td></tr>
<tr class="memdesc:ab96c3f81fbb888c414a2f850d0121ee7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the cost of the TSP path using the Triangle Inequality heuristic.  <a href="class_data.html#ab96c3f81fbb888c414a2f850d0121ee7">More...</a><br /></td></tr>
<tr class="separator:ab96c3f81fbb888c414a2f850d0121ee7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe856ec5dc4cad1c2759a7142a88b82b"><td class="memItemLeft" align="right" valign="top">vector&lt; <a class="el" href="class_vertex.html">Vertex</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_data.html#afe856ec5dc4cad1c2759a7142a88b82b">tspNearestNeighbour</a> ()</td></tr>
<tr class="memdesc:afe856ec5dc4cad1c2759a7142a88b82b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the cost of the Travelling Salesperson Problem (TSP) path using the Nearest Neighbour heuristic.  <a href="class_data.html#afe856ec5dc4cad1c2759a7142a88b82b">More...</a><br /></td></tr>
<tr class="separator:afe856ec5dc4cad1c2759a7142a88b82b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6618cadfe8ee097da166f3e8c801bc37"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_data.html#a6618cadfe8ee097da166f3e8c801bc37">getPathDist</a> (vector&lt; <a class="el" href="class_vertex.html">Vertex</a> * &gt; path)</td></tr>
<tr class="memdesc:a6618cadfe8ee097da166f3e8c801bc37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the sum of the weights of the edges in a path.  <a href="class_data.html#a6618cadfe8ee097da166f3e8c801bc37">More...</a><br /></td></tr>
<tr class="separator:a6618cadfe8ee097da166f3e8c801bc37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fb1a0ae925c6c9a7e871078ae2a886b"><td class="memItemLeft" align="right" valign="top">vector&lt; <a class="el" href="class_vertex.html">Vertex</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_data.html#a8fb1a0ae925c6c9a7e871078ae2a886b">swap2opt</a> (vector&lt; <a class="el" href="class_vertex.html">Vertex</a> * &gt; path, int i, int j)</td></tr>
<tr class="memdesc:a8fb1a0ae925c6c9a7e871078ae2a886b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps a portion of the given path using the 2-opt technique.  <a href="class_data.html#a8fb1a0ae925c6c9a7e871078ae2a886b">More...</a><br /></td></tr>
<tr class="separator:a8fb1a0ae925c6c9a7e871078ae2a886b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab69aab8c0caa7e223bfc11971a31c572"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_data.html#ab69aab8c0caa7e223bfc11971a31c572">tsp2opt</a> (vector&lt; <a class="el" href="class_vertex.html">Vertex</a> * &gt; &amp;path, int maxIterations)</td></tr>
<tr class="memdesc:ab69aab8c0caa7e223bfc11971a31c572"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the 2-opt algorithm to improve the given TSP path.  <a href="class_data.html#ab69aab8c0caa7e223bfc11971a31c572">More...</a><br /></td></tr>
<tr class="separator:ab69aab8c0caa7e223bfc11971a31c572"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1d8ed2a5a9764a20e0b8c0100dfc729"><td class="memItemLeft" align="right" valign="top"><a id="ac1d8ed2a5a9764a20e0b8c0100dfc729" name="ac1d8ed2a5a9764a20e0b8c0100dfc729"></a>
vector&lt; <a class="el" href="class_vertex.html">Vertex</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>swap3opt</b> (vector&lt; <a class="el" href="class_vertex.html">Vertex</a> * &gt; path, int start, int mid, int end)</td></tr>
<tr class="separator:ac1d8ed2a5a9764a20e0b8c0100dfc729"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbd42922f24f064c09c8960c5a4abe5b"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_data.html#adbd42922f24f064c09c8960c5a4abe5b">tsp3opt</a> (vector&lt; <a class="el" href="class_vertex.html">Vertex</a> * &gt; &amp;path, int maxIterations)</td></tr>
<tr class="memdesc:adbd42922f24f064c09c8960c5a4abe5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the 3-opt algorithm to improve the given TSP path.  <a href="class_data.html#adbd42922f24f064c09c8960c5a4abe5b">More...</a><br /></td></tr>
<tr class="separator:adbd42922f24f064c09c8960c5a4abe5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:acb6d36a153496f215344da5c2c1dcc68"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_data.html#acb6d36a153496f215344da5c2c1dcc68">haversine</a> (double lat1, double lon1, double lat2, double lon2)</td></tr>
<tr class="memdesc:acb6d36a153496f215344da5c2c1dcc68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates distance between two nodes using the Haversine formula with the values of each latitude and longitude.  <a href="class_data.html#acb6d36a153496f215344da5c2c1dcc68">More...</a><br /></td></tr>
<tr class="separator:acb6d36a153496f215344da5c2c1dcc68"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a6618cadfe8ee097da166f3e8c801bc37" name="a6618cadfe8ee097da166f3e8c801bc37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6618cadfe8ee097da166f3e8c801bc37">&#9670;&#160;</a></span>getPathDist()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double Data::getPathDist </td>
          <td>(</td>
          <td class="paramtype">vector&lt; <a class="el" href="class_vertex.html">Vertex</a> * &gt;&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the sum of the weights of the edges in a path. </p>
<p >COMPLEXITY: O(V+E), where V is the number of vertices, and E the number of edges</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>A vector of <a class="el" href="class_vertex.html">Vertex</a> pointers representing the path. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The sum of the weights of the edges in the path. </dd></dl>

</div>
</div>
<a id="a8887ef4ba084b4f8c60858e9d16ef0a8" name="a8887ef4ba084b4f8c60858e9d16ef0a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8887ef4ba084b4f8c60858e9d16ef0a8">&#9670;&#160;</a></span>getPreorderWalk()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; <a class="el" href="class_vertex.html">Vertex</a> * &gt; Data::getPreorderWalk </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the Preorder Walk of the <a class="el" href="class_graph.html">Graph</a>. </p>
<p >This function returns a vector of vertices representing the preorder walk of the graph. The preorder walk is obtained by performing a Depth-First Search (DFS) traversal starting from the first vertex of the graph.</p>
<p >COMPLEXITY: O(V+E), where V is the number of vertices, and E is the number of edges of the MST</p>
<dl class="section return"><dt>Returns</dt><dd>path A vector of vertices representing the preorder walk of the graph. </dd></dl>

</div>
</div>
<a id="acb6d36a153496f215344da5c2c1dcc68" name="acb6d36a153496f215344da5c2c1dcc68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb6d36a153496f215344da5c2c1dcc68">&#9670;&#160;</a></span>haversine()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double Data::haversine </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>lat1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>lon1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>lat2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>lon2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates distance between two nodes using the Haversine formula with the values of each latitude and longitude. </p>
<p >COMPLEXITY: O(log(n))</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lat1</td><td>latitude of the first node </td></tr>
    <tr><td class="paramname">lon1</td><td>longitude of the first node </td></tr>
    <tr><td class="paramname">lat2</td><td>latitude of the second node </td></tr>
    <tr><td class="paramname">lon2</td><td>longitude of the second node </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>distance between the two nodes </dd></dl>

</div>
</div>
<a id="a8fb1a0ae925c6c9a7e871078ae2a886b" name="a8fb1a0ae925c6c9a7e871078ae2a886b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8fb1a0ae925c6c9a7e871078ae2a886b">&#9670;&#160;</a></span>swap2opt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; <a class="el" href="class_vertex.html">Vertex</a> * &gt; Data::swap2opt </td>
          <td>(</td>
          <td class="paramtype">vector&lt; <a class="el" href="class_vertex.html">Vertex</a> * &gt;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Swaps a portion of the given path using the 2-opt technique. </p>
<p >COMPLEXITY: O(V), where V is the number of vertices</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>The original path to be modified. </td></tr>
    <tr><td class="paramname">start</td><td>The starting index of the portion to be swapped. </td></tr>
    <tr><td class="paramname">end</td><td>The ending index of the portion to be swapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The modified path with the specified portion swapped. </dd></dl>

</div>
</div>
<a id="ab69aab8c0caa7e223bfc11971a31c572" name="ab69aab8c0caa7e223bfc11971a31c572"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab69aab8c0caa7e223bfc11971a31c572">&#9670;&#160;</a></span>tsp2opt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double Data::tsp2opt </td>
          <td>(</td>
          <td class="paramtype">vector&lt; <a class="el" href="class_vertex.html">Vertex</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maxIterations</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Applies the 2-opt algorithm to improve the given TSP path. </p>
<p >The 2-opt algorithm is an iterative algorithm that attempts to improve an existing path by swapping two edges. It does this by trying to find two edges that, if swapped, would result in a shorter path. If such edges are found, the swap is performed and the process is repeated until no further improvements can be made. The algorithm is guaranteed to terminate, and it is also guaranteed to never produce a path longer than the original. However, it is not guaranteed to produce the shortest possible path.</p>
<p >COMPLEXITY: O(V^3*E), where V is the number of vertices, and E the number of edges</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>The TSP path to be optimized. </td></tr>
    <tr><td class="paramname">maxIterations</td><td>The maximum number of iterations to perform. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The optimized TSP path's total distance. </dd></dl>

</div>
</div>
<a id="adbd42922f24f064c09c8960c5a4abe5b" name="adbd42922f24f064c09c8960c5a4abe5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbd42922f24f064c09c8960c5a4abe5b">&#9670;&#160;</a></span>tsp3opt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double Data::tsp3opt </td>
          <td>(</td>
          <td class="paramtype">vector&lt; <a class="el" href="class_vertex.html">Vertex</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maxIterations</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Applies the 3-opt algorithm to improve the given TSP path. </p>
<p >The 3-opt algorithm is an iterative algorithm that attempts to improve an existing path by swapping three edges. In this case, it can apply swaps to both pairs or groups of three edges (combining 2-opt with pure 3-opt approach), to provide a better solution. It does this by trying to find three edges that, if swapped, would result in a shorter path. If such edges are found, the swap is performed and the process is repeated until no further improvements can be made. Like the 2-opt algorithm, the 3-opt algorithm is guaranteed to terminate and never produce a path longer than the original. However, it is not guaranteed to produce the shortest possible path.</p>
<p >COMPLEXITY: O(V^4*E), where V is the number of vertices, and E the number of edges</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>The TSP path to be optimized. </td></tr>
    <tr><td class="paramname">maxIterations</td><td>The maximum number of iterations to perform. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The optimized TSP path's total distance. </dd></dl>

</div>
</div>
<a id="a4962c86093432dd3093b71805add323a" name="a4962c86093432dd3093b71805add323a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4962c86093432dd3093b71805add323a">&#9670;&#160;</a></span>tspBT()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double Data::tspBT </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>path</em>[]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Solves the Travelling Salesperson Problem (TSP) using a Backtracking algorithm. </p>
<p >This function finds the shortest path that visits all nodes in the graph, starting from node 0 and returning to it. It uses a Backtracking algorithm by calling the auxiliary function tspBTAux. Explores all possible paths and returns the cost of the best path found. It's only useful for small graphs, because of its time complexity.</p>
<p >COMPLEXITY: O(V!), V being the number of vertices in the graph.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>The number of nodes in the graph. </td></tr>
    <tr><td class="paramname">path</td><td>An array to store the resulting path. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The cost of the best path found. </dd></dl>

</div>
</div>
<a id="a1947b3d8101c095e648980d3d7a6fd61" name="a1947b3d8101c095e648980d3d7a6fd61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1947b3d8101c095e648980d3d7a6fd61">&#9670;&#160;</a></span>tspBTAux()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Data::tspBTAux </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>path</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>currentPath</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>curr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>best</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>curr_n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Auxiliar function to solve the Travelling Salesperson Problem (TSP) using a Backtracking algorithm. </p>
<p >This function finds the shortest path that visits all nodes in the graph, starting from node 0 and returning to it. It uses a Backtracking algorithm to explore all possible paths and keeps track of the best path found.</p>
<p >COMPLEXITY: O(V!), V being the number of vertices in the graph.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>The number of nodes in the graph. </td></tr>
    <tr><td class="paramname">path</td><td>An array to store the resulting path. </td></tr>
    <tr><td class="paramname">currentPath</td><td>An array to store the current path being explored. </td></tr>
    <tr><td class="paramname">curr</td><td>The current cost of the path being explored. </td></tr>
    <tr><td class="paramname">best</td><td>The best cost found so far. </td></tr>
    <tr><td class="paramname">curr_n</td><td>The current number of nodes visited in the path. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afe856ec5dc4cad1c2759a7142a88b82b" name="afe856ec5dc4cad1c2759a7142a88b82b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe856ec5dc4cad1c2759a7142a88b82b">&#9670;&#160;</a></span>tspNearestNeighbour()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; <a class="el" href="class_vertex.html">Vertex</a> * &gt; Data::tspNearestNeighbour </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the cost of the Travelling Salesperson Problem (TSP) path using the Nearest Neighbour heuristic. </p>
<p >Starts with vertex 0 as the starting point and repeatedly selects the nearest unvisited vertex to extend the current path. This process continues until all vertices have been visited, and then the path is closed by returning to the initial vertex. The resulting path may not always be the optimal solution, but it provides a reasonably good approximation.</p>
<p >COMPLEXITY: O(V + E), where V is the number of vertices, and E the number of edges </p><dl class="section return"><dt>Returns</dt><dd>A vector of <a class="el" href="class_vertex.html">Vertex</a> pointers representing the TSP path generated by the Nearest Neighbour heuristic. The path starts and ends at the same vertex, forming a closed loop. If the graph is not complete (some vertices are not connected), an empty path is returned. </dd></dl>

</div>
</div>
<a id="ab96c3f81fbb888c414a2f850d0121ee7" name="ab96c3f81fbb888c414a2f850d0121ee7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab96c3f81fbb888c414a2f850d0121ee7">&#9670;&#160;</a></span>tspTriangle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double Data::tspTriangle </td>
          <td>(</td>
          <td class="paramtype">vector&lt; <a class="el" href="class_vertex.html">Vertex</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the cost of the TSP path using the Triangle Inequality heuristic. </p>
<p >It first constructs a minimum spanning tree of the graph using Prim's algorithm. Then, it generates a preorder walk of the minimum spanning tree and appends the starting vertex to form a closed path. Finally, it calculates the total cost of the path by summing the weights of the edges. If a direct edge exists between two adjacent vertices in the path, the weight of that edge is used. Otherwise, the Haversine formula is used to calculate the distance between the vertices based on their coordinates.</p>
<p >COMPLEXITY: O((V+E) * log(V)), where V is the number of vertices, and E the number of edges</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>A vector of <a class="el" href="class_vertex.html">Vertex</a> pointers to store the resulting path. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The cost of the path. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>C:/Users/User/Desktop/DA projetos/DA2023_PRJ2_G15_1/DA-PROJECT2/src/algorithms/<a class="el" href="_data_8h_source.html">Data.h</a></li>
<li>C:/Users/User/Desktop/DA projetos/DA2023_PRJ2_G15_1/DA-PROJECT2/src/algorithms/Data.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.5
</small></address>
</body>
</html>
