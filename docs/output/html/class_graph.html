<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.5"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>2nd DA Project: Graph Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">2nd DA Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.5 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="class_graph-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">Graph Class Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ad354c018724ef3f137a0b8554089105e"><td class="memItemLeft" align="right" valign="top"><a id="ad354c018724ef3f137a0b8554089105e" name="ad354c018724ef3f137a0b8554089105e"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>addVertex</b> (const int &amp;id)</td></tr>
<tr class="separator:ad354c018724ef3f137a0b8554089105e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abece134d2ebd0c024a67619ea46dbd64"><td class="memItemLeft" align="right" valign="top"><a id="abece134d2ebd0c024a67619ea46dbd64" name="abece134d2ebd0c024a67619ea46dbd64"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>addVertex</b> (const int &amp;id, double latitude, double longitude)</td></tr>
<tr class="separator:abece134d2ebd0c024a67619ea46dbd64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a516f4487d70f4b15e413447afa8c2310"><td class="memItemLeft" align="right" valign="top"><a id="a516f4487d70f4b15e413447afa8c2310" name="a516f4487d70f4b15e413447afa8c2310"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>addEdge</b> (const int &amp;sourc, const int &amp;dest, double w)</td></tr>
<tr class="separator:a516f4487d70f4b15e413447afa8c2310"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d6b6b10ebe49cc0191ab45151cd49e7"><td class="memItemLeft" align="right" valign="top"><a id="a5d6b6b10ebe49cc0191ab45151cd49e7" name="a5d6b6b10ebe49cc0191ab45151cd49e7"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>addBidirectionalEdge</b> (const int &amp;sourc, const int &amp;dest, double w)</td></tr>
<tr class="separator:a5d6b6b10ebe49cc0191ab45151cd49e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb5e0517e2979c54eebdafc2a9875e8f"><td class="memItemLeft" align="right" valign="top"><a id="abb5e0517e2979c54eebdafc2a9875e8f" name="abb5e0517e2979c54eebdafc2a9875e8f"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>getNumVertex</b> () const</td></tr>
<tr class="separator:abb5e0517e2979c54eebdafc2a9875e8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34dc8268e703217705d6ba9ac8b02170"><td class="memItemLeft" align="right" valign="top"><a id="a34dc8268e703217705d6ba9ac8b02170" name="a34dc8268e703217705d6ba9ac8b02170"></a>
std::unordered_map&lt; int, <a class="el" href="class_vertex.html">Vertex</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>getVertexSet</b> () const</td></tr>
<tr class="separator:a34dc8268e703217705d6ba9ac8b02170"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a559b70457eba466fe03bc54134879431"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a559b70457eba466fe03bc54134879431">prim</a> ()</td></tr>
<tr class="memdesc:a559b70457eba466fe03bc54134879431"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a minimum spanning tree using Prim's algorithm and returns its total weight.  <a href="class_graph.html#a559b70457eba466fe03bc54134879431">More...</a><br /></td></tr>
<tr class="separator:a559b70457eba466fe03bc54134879431"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa566776683d3b9b0ca53b97fa5ba1e66"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#aa566776683d3b9b0ca53b97fa5ba1e66">dfsPrim</a> (<a class="el" href="class_vertex.html">Vertex</a> *source, std::vector&lt; <a class="el" href="class_vertex.html">Vertex</a> * &gt; &amp;res)</td></tr>
<tr class="memdesc:aa566776683d3b9b0ca53b97fa5ba1e66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a Depth-First Search traversal on the minimum spanning tree rooted at the specified source vertex. This function recursively traverses the minimum spanning tree in a depth-first manner starting from the given source vertex. It marks each visited vertex as visited and adds it to the resulting vector in the order of the traversal. For each vertex in the reverse path of the current vertex, it recursively calls the dfsPrim function if the vertex has not been visited.  <a href="class_graph.html#aa566776683d3b9b0ca53b97fa5ba1e66">More...</a><br /></td></tr>
<tr class="separator:aa566776683d3b9b0ca53b97fa5ba1e66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1c7af5ab7a9fc6ce190779170bb655c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#ad1c7af5ab7a9fc6ce190779170bb655c">clearGraph</a> ()</td></tr>
<tr class="memdesc:ad1c7af5ab7a9fc6ce190779170bb655c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the graph.  <a href="class_graph.html#ad1c7af5ab7a9fc6ce190779170bb655c">More...</a><br /></td></tr>
<tr class="separator:ad1c7af5ab7a9fc6ce190779170bb655c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-attribs" name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:ab857650ab750306ac716ae6b8510fe41"><td class="memItemLeft" align="right" valign="top"><a id="ab857650ab750306ac716ae6b8510fe41" name="ab857650ab750306ac716ae6b8510fe41"></a>
std::unordered_map&lt; int, <a class="el" href="class_vertex.html">Vertex</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>vertexSet</b></td></tr>
<tr class="separator:ab857650ab750306ac716ae6b8510fe41"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ad1c7af5ab7a9fc6ce190779170bb655c" name="ad1c7af5ab7a9fc6ce190779170bb655c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1c7af5ab7a9fc6ce190779170bb655c">&#9670;&#160;</a></span>clearGraph()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Graph::clearGraph </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clears the graph. </p>
<p >The function deletes all the vertices in the graph and clears the vertex set. </p>

</div>
</div>
<a id="aa566776683d3b9b0ca53b97fa5ba1e66" name="aa566776683d3b9b0ca53b97fa5ba1e66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa566776683d3b9b0ca53b97fa5ba1e66">&#9670;&#160;</a></span>dfsPrim()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Graph::dfsPrim </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_vertex.html">Vertex</a> *&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="class_vertex.html">Vertex</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>res</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs a Depth-First Search traversal on the minimum spanning tree rooted at the specified source vertex. This function recursively traverses the minimum spanning tree in a depth-first manner starting from the given source vertex. It marks each visited vertex as visited and adds it to the resulting vector in the order of the traversal. For each vertex in the reverse path of the current vertex, it recursively calls the dfsPrim function if the vertex has not been visited. </p>
<p >COMPLEXITY: O(V+E), where V is the number of vertices and E is the number of edges of the MST (obtained by the prim algorithm).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td><a class="el" href="class_vertex.html">Vertex</a> pointer that represents the source vertex from which the traversal starts. </td></tr>
    <tr><td class="paramname">res</td><td>A vector of <a class="el" href="class_vertex.html">Vertex</a> pointers to store the resulting traversal path. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a559b70457eba466fe03bc54134879431" name="a559b70457eba466fe03bc54134879431"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a559b70457eba466fe03bc54134879431">&#9670;&#160;</a></span>prim()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double Graph::prim </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs a minimum spanning tree using Prim's algorithm and returns its total weight. </p>
<p >The function constructs a minimum spanning tree of the graph using Prim's algorithm. Iteratively selects the vertex with the minimum distance from the priority queue and marks it as visited. For each unvisited vertex, it checks if there is a direct edge from the selected vertex to that vertex. If such an edge exists, it updates the distance and path information of the vertex if the new distance is smaller. If there is no direct edge, uses the Haversine formula. If the new distance is smaller than the previous distance, the vertex is inserted or updated in the priority queue accordingly. Finally, the function establishes the reverse path connections between vertices in the minimum spanning tree.</p>
<p >COMPLEXITY: O((V+E) * log(V)), where V is the number of vertices in the graph and E the number of edges.</p>
<dl class="section return"><dt>Returns</dt><dd>The total weight of the minimum spanning tree. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>C:/Users/User/Desktop/DA projetos/DA2023_PRJ2_G15_1/DA-PROJECT2/src/dataStructures/<a class="el" href="_graph_8h_source.html">Graph.h</a></li>
<li>C:/Users/User/Desktop/DA projetos/DA2023_PRJ2_G15_1/DA-PROJECT2/src/dataStructures/Graph.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.5
</small></address>
</body>
</html>
